I want to see thousands of messages go between servers. It is often simpler to have a general solution than to have a specific solution that sends message1, message2 and message3 etc.


Servers should be absolutely quiet. println is good for debugging, but it really slows down a server. Also, when thousands of requests are coming in, a particular println is hard to spot; it'll scroll off the screen before you notice


I want you to try hard and break your own code. Some examples:
Broadcast messages that are 60000 bytes in length, say. If it fails, perhaps there are no big enough buffers left. You might find a parameter in the OS or ZMQ that specifies the size of the buffers. That's a parameter that may need to be present in your configuration file as well. There should be no arbitrary limits in your code.


Have everyone broadcast to everyone else
Have a round-robin test where server 1 sends to server 2, server 2 sends to server 3 and so on. This kind of thing is good for measuring performance.


Do broadcasts with one server not yet started. Then start the remaining server, and verify that from that point on, the new server gets all the messages


At some point we'll have to make sure that the cluster runs over several machines. When it is running on the same machine, it doesn't involve the networking hardware; it is merely a buffer transfer from one process to another inside the TCP stack. The testing becomes slightly more difficult, because a test has to launch processes on multiple machines.


Sometimes you may be accidentally sharing structures from different goroutines without protecting them with a mutex. Go has a built-in "race detector" that often detects race conditions. Try running your test and examples with the -race flag.

